#!/usr/bin/env ysh

# Weird name, provides 'log' and 'die'
#source --builtin osh/two.sh

if (len(ARGV) < 1) {
  echo Need at least one argument to run a file
  exit 1
}
proc info {
  echo '    ##' @[ARGV]
}

# TODO: Argparse to run only a single stage


case (ARGV[0]) {
  *hay {
    hay define pipeline/task/RUN
    var h = parseHay(ARGV[0])
    var pipelines = evalHay(h)
  }
  # If we have a YSH file, parse that
  # TODO: Oils sandboxed is still pending. That here should be sandboxed!
  *ysh {
    osh -c "
      source $[ARGV[0]]
      var pipelines = _hay()
      json write (pipelines)
    "
  }
  (else) {
    info "Need a hay or ysh file"
    exit 1
  }
}

#= pipelines

# Important: The whole part from here on could be written in any language
# The idea is NOT to have a CI *written in ysh*.
# The idea is to have a CI *configured in hay*.
# not yaml + go templates. or yaml + jinja. or yaml + weird custom interpretation
# In most cases, you have *one* language

proc run-task (;task, env_override) {
  info Run task: $[task.args[0]]
  var env = []
  if ("environment" in task.attrs) {
    for variable, info in (task.attrs.environment) {
      if (variable in env_override) {
        setvar env = env ++ :|--env $variable=$[env_override[variable]]|
      } elif ("default" in info) {
        setvar env = env ++ :|--env $variable=$[info.default]|
      } elif ("required" in info) {
        die
        # TODO: This should happen before any task runs
      }
    }
  }
  for run in (task.children) {
    #info podman run -ti --rm @[env] --mount type=bind,source=./,target=/$(basename $(pwd)) --init-path=/$(basename $(pwd)) $[task.attrs.image] @[task.attrs.shell] $[run.code_str]

    podman run -ti --rm @[env] --mount type=bind,source=./,target=/$(basename $(pwd)) --init-path=/$(basename $(pwd)) $[task.attrs.image] @[task.attrs.shell] $[run.code_str]
  }
}

for pipeline in (pipelines.children) {
  var stages = pipeline.attrs.stages
  var s = {}
  # TODO: needs and stuff
  for stage in (stages) {
    setvar s[stage] = []
  }

  if (pipeline.type !== "pipeline") { continue }
  for task in (pipeline.children) {
    if (task.type !== "task") { continue }
    #= task
    call s[task.attrs.stage]->append(task)
  }

  for stage in (stages) {
    info "run stage: $stage"
    var environment = {}
    if ("environment" in pipeline.attrs) {
      setvar environment = pipeline.attrs.environment
    }
    for task in (s[stage]) {
      run-task (task, environment)
    }
  }
}
